# requirements:
# pip install smartapi-python pyotp logzero backtrader pandas numpy scikit-learn
# pip install tensorflow torch transformers newsapi-python yfinance talib

import datetime
import pandas as pd
import numpy as np
import pyotp
from logzero import logger
from SmartApi import SmartConnect
import backtrader as bt
import talib
import torch
import torch.nn as nn
from transformers import AutoTokenizer, AutoModelForSequenceClassification
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.preprocessing import MinMaxScaler
import warnings
warnings.filterwarnings('ignore')

# Angel One API Configuration
API_KEY = "YOUR_API_KEY"
USERNAME = "YOUR_CLIENT_CODE"
PASSWORD = "YOUR_PIN"
TOTP_TOKEN = "YOUR_QR_SECRET"

# Initialize SmartAPI
smart_api = SmartConnect(API_KEY)
totp = pyotp.TOTP(TOTP_TOKEN).now()
sess = smart_api.generateSession(USERNAME, PASSWORD, totp)
AUTH_TOKEN = sess["data"]["jwtToken"]
REFRESH_TOKEN = sess["data"]["refreshToken"]

class AttentionLSTM(nn.Module):
    """LSTM with Attention Mechanism for Time Series Prediction"""
    def __init__(self, input_size, hidden_size, num_layers, output_size):
        super(AttentionLSTM, self).__init__()
        self.hidden_size = hidden_size
        self.num_layers = num_layers
        
        self.lstm = nn.LSTM(input_size, hidden_size, num_layers, batch_first=True, dropout=0.2)
        self.attention = nn.MultiheadAttention(hidden_size, num_heads=8, dropout=0.1)
        self.layer_norm = nn.LayerNorm(hidden_size)
        self.dropout = nn.Dropout(0.3)
        self.fc = nn.Linear(hidden_size, output_size)
        
    def forward(self, x):
        # LSTM forward pass
        lstm_out, (h_n, c_n) = self.lstm(x)
        
        # Apply attention mechanism
        attended, _ = self.attention(lstm_out, lstm_out, lstm_out)
        attended = self.layer_norm(attended + lstm_out)  # Residual connection
        
        # Global average pooling
        pooled = torch.mean(attended, dim=1)
        pooled = self.dropout(pooled)
        
        # Final prediction
        output = self.fc(pooled)
        return output

class CNNFeatureExtractor(nn.Module):
    """1D CNN for extracting local patterns from time series"""
    def __init__(self, input_channels, sequence_length):
        super(CNNFeatureExtractor, self).__init__()
        self.conv1 = nn.Conv1d(input_channels, 64, kernel_size=3, padding=1)
        self.conv2 = nn.Conv1d(64, 128, kernel_size=3, padding=1)
        self.conv3 = nn.Conv1d(128, 64, kernel_size=3, padding=1)
        self.pool = nn.MaxPool1d(2)
        self.dropout = nn.Dropout(0.3)
        self.fc = nn.Linear(64 * (sequence_length // 4), 32)
        
    def forward(self, x):
        x = x.transpose(1, 2)  # Change to (batch, channels, sequence)
        x = torch.relu(self.conv1(x))
        x = self.pool(x)
        x = torch.relu(self.conv2(x))
        x = self.pool(x)
        x = torch.relu(self.conv3(x))
        x = x.view(x.size(0), -1)
        x = self.dropout(x)
        x = torch.relu(self.fc(x))
        return x

class SentimentAnalyzer:
    """Financial Sentiment Analysis using FinBERT"""
    def __init__(self):
        self.tokenizer = AutoTokenizer.from_pretrained("ProsusAI/finbert")
        self.model = AutoModelForSequenceClassification.from_pretrained("ProsusAI/finbert")
        
    def get_sentiment(self, text):
        inputs = self.tokenizer(text, return_tensors="pt", truncation=True, padding=True, max_length=512)
        with torch.no_grad():
            outputs = self.model(**inputs)
            predictions = torch.nn.functional.softmax(outputs.logits, dim=-1)
            sentiment_score = predictions[0][2].item() - predictions[0][0].item()  # positive - negative
        return sentiment_score

class EnsembleStrategy(bt.Strategy):
    """Advanced Ensemble Trading Strategy"""
    
    params = (
        ('lookback', 60),
        ('prediction_horizon', 5),
        ('risk_per_trade', 0.02),
        ('stop_loss_atr_mult', 2.0),
        ('take_profit_mult', 3.0),
        ('sentiment_threshold', 0.1),
        ('volatility_lookback', 20),
    )
    
    def __init__(self):
        # Technical Indicators using TA-Lib
        self.rsi = bt.talib.RSI(self.data.close, timeperiod=14)
        self.macd = bt.talib.MACD(self.data.close)
        self.bb = bt.talib.BBANDS(self.data.close)
        self.atr = bt.talib.ATR(self.data.high, self.data.low, self.data.close, timeperiod=14)
        self.adx = bt.talib.ADX(self.data.high, self.data.low, self.data.close)
        self.stoch = bt.talib.STOCH(self.data.high, self.data.low, self.data.close)
        
        # Initialize models
        self.scaler = MinMaxScaler()
        self.sentiment_analyzer = SentimentAnalyzer()
        self.lstm_model = AttentionLSTM(input_size=15, hidden_size=128, num_layers=2, output_size=1)
        self.cnn_model = CNNFeatureExtractor(input_channels=15, sequence_length=self.p.lookback)
        
        # Ensemble components
        self.rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
        self.gb_model = GradientBoostingRegressor(n_estimators=100, random_state=42)
        
        # Trading state
        self.data_buffer = []
        self.sentiment_scores = []
        self.model_trained = False
        self.position_size = 0
        self.entry_price = 0
        self.stop_loss = 0
        self.take_profit = 0
        
    def prepare_features(self):
        """Prepare feature matrix for ML models"""
        if len(self.data_buffer) < self.p.lookback:
            return None
            
        features = []
        for i in range(len(self.data_buffer)):
            row = self.data_buffer[i]
            features.append([
                row['open'], row['high'], row['low'], row['close'], row['volume'],
                row['rsi'], row['macd'], row['macd_signal'], row['macd_hist'],
                row['bb_upper'], row['bb_middle'], row['bb_lower'],
                row['atr'], row['adx'], row['stoch_k']
            ])
        return np.array(features)
    
    def train_models(self, X, y):
        """Train ensemble models"""
        if len(X) < 100:  # Need sufficient data
            return
            
        # Prepare data for different models
        X_scaled = self.scaler.fit_transform(X)
        
        # Train traditional ML models
        self.rf_model.fit(X_scaled[:-self.p.prediction_horizon], y[self.p.prediction_horizon:])
        self.gb_model.fit(X_scaled[:-self.p.prediction_horizon], y[self.p.prediction_horizon:])
        
        # Prepare sequences for deep learning models
        sequences = []
        for i in range(self.p.lookback, len(X_scaled)):
            sequences.append(X_scaled[i-self.p.lookback:i])
        
        if len(sequences) > 50:
            X_seq = torch.FloatTensor(sequences[:-self.p.prediction_horizon])
            y_seq = torch.FloatTensor(y[self.p.lookback+self.p.prediction_horizon:]).unsqueeze(1)
            
            # Train LSTM with attention
            optimizer = torch.optim.Adam(self.lstm_model.parameters(), lr=0.001)
            criterion = nn.MSELoss()
            
            for epoch in range(50):  # Quick training
                optimizer.zero_grad()
                outputs = self.lstm_model(X_seq)
                loss = criterion(outputs, y_seq)
                loss.backward()
                optimizer.step()
        
        self.model_trained = True
    
    def get_ensemble_prediction(self):
        """Generate ensemble prediction"""
        if not self.model_trained or len(self.data_buffer) < self.p.lookback:
            return 0
        
        features = self.prepare_features()
        X_scaled = self.scaler.transform(features)
        
        # Get predictions from different models
        predictions = []
        
        # Traditional ML predictions
        rf_pred = self.rf_model.predict(X_scaled[-1:])
        gb_pred = self.gb_model.predict(X_scaled[-1:])
        predictions.extend([rf_pred[0], gb_pred[0]])
        
        # Deep learning prediction
        if len(X_scaled) >= self.p.lookback:
            X_seq = torch.FloatTensor(X_scaled[-self.p.lookback:]).unsqueeze(0)
            with torch.no_grad():
                lstm_pred = self.lstm_model(X_seq).item()
            predictions.append(lstm_pred)
        
        # Ensemble using weighted average (equal weights for simplicity)
        ensemble_pred = np.mean(predictions) if predictions else 0
        return ensemble_pred
    
    def calculate_position_size(self):
        """Calculate position size based on Kelly Criterion and risk management"""
        portfolio_value = self.broker.getvalue()
        volatility = np.std([bar['close'] for bar in self.data_buffer[-self.p.volatility_lookback:]])
        
        # Basic position sizing (2% risk per trade)
        risk_amount = portfolio_value * self.p.risk_per_trade
        current_atr = self.atr[0] if self.atr[0] else volatility
        
        if current_atr > 0:
            position_size = int(risk_amount / (current_atr * self.p.stop_loss_atr_mult))
            return min(position_size, int(portfolio_value * 0.1 / self.data.close[0]))  # Max 10% of portfolio
        return 0
    
    def next(self):
        # Store current bar data
        current_bar = {
            'open': self.data.open[0],
            'high': self.data.high[0],
            'low': self.data.low[0],
            'close': self.data.close[0],
            'volume': self.data.volume[0],
            'rsi': self.rsi[0] if not np.isnan(self.rsi[0]) else 50,
            'macd': self.macd.macd[0] if not np.isnan(self.macd.macd[0]) else 0,
            'macd_signal': self.macd.macdsignal[0] if not np.isnan(self.macd.macdsignal[0]) else 0,
            'macd_hist': self.macd.macdhist[0] if not np.isnan(self.macd.macdhist[0]) else 0,
            'bb_upper': self.bb.top[0] if not np.isnan(self.bb.top[0]) else self.data.close[0],
            'bb_middle': self.bb.mid[0] if not np.isnan(self.bb.mid[0]) else self.data.close[0],
            'bb_lower': self.bb.bot[0] if not np.isnan(self.bb.bot[0]) else self.data.close[0],
            'atr': self.atr[0] if not np.isnan(self.atr[0]) else 0,
            'adx': self.adx[0] if not np.isnan(self.adx[0]) else 25,
            'stoch_k': self.stoch.slowk[0] if not np.isnan(self.stoch.slowk[0]) else 50,
        }
        self.data_buffer.append(current_bar)
        
        # Train models periodically
        if len(self.data_buffer) > 200 and len(self.data_buffer) % 50 == 0:
            features = self.prepare_features()
            if features is not None:
                returns = [bar['close'] for bar in self.data_buffer]
                self.train_models(features, returns)
        
        # Generate trading signals
        if self.model_trained and len(self.data_buffer) >= self.p.lookback:
            prediction = self.get_ensemble_prediction()
            current_price = self.data.close[0]
            
            # Risk management - exit conditions
            if self.position:
                if self.position.size > 0:  # Long position
                    if current_price <= self.stop_loss or current_price >= self.take_profit:
                        self.close()
                elif self.position.size < 0:  # Short position
                    if current_price >= self.stop_loss or current_price <= self.take_profit:
                        self.close()
            
            # Entry conditions
            if not self.position:
                # Multi-factor signal generation
                technical_signal = 0
                
                # RSI signal
                if self.rsi[0] < 30:
                    technical_signal += 1
                elif self.rsi[0] > 70:
                    technical_signal -= 1
                
                # MACD signal
                if self.macd.macd[0] > self.macd.macdsignal[0]:
                    technical_signal += 1
                else:
                    technical_signal -= 1
                
                # Bollinger Bands signal
                if current_price < self.bb.bot[0]:
                    technical_signal += 1
                elif current_price > self.bb.top[0]:
                    technical_signal -= 1
                
                # ADX trend strength
                trend_strength = self.adx[0] > 25
                
                # Ensemble ML prediction signal
                prediction_signal = 1 if prediction > current_price * 1.005 else (-1 if prediction < current_price * 0.995 else 0)
                
                # Combined signal
                total_signal = technical_signal + prediction_signal * 2  # Weight ML prediction higher
                
                # Entry logic
                if total_signal >= 3 and trend_strength:  # Long entry
                    size = self.calculate_position_size()
                    if size > 0:
                        self.buy(size=size)
                        self.entry_price = current_price
                        self.stop_loss = current_price - (self.atr[0] * self.p.stop_loss_atr_mult)
                        self.take_profit = current_price + (self.atr[0] * self.p.stop_loss_atr_mult * self.p.take_profit_mult)
                
                elif total_signal <= -3 and trend_strength:  # Short entry
                    size = self.calculate_position_size()
                    if size > 0:
                        self.sell(size=size)
                        self.entry_price = current_price
                        self.stop_loss = current_price + (self.atr[0] * self.p.stop_loss_atr_mult)
                        self.take_profit = current_price - (self.atr[0] * self.p.stop_loss_atr_mult * self.p.take_profit_mult)

def fetch_intraday_data(symbol_token, start_dt, end_dt, interval="FIVE_MINUTE"):
    """Fetch historical data from Angel One"""
    params = {
        "exchange": "NSE",
        "symboltoken": symbol_token,
        "interval": interval,
        "fromdate": start_dt.strftime("%Y-%m-%d %H:%M"),
        "todate": end_dt.strftime("%Y-%m-%d %H:%M")
    }
    resp = smart_api.getCandleData(params)
    data = resp["data"]
    df = pd.DataFrame(data, columns=["datetime","open","high","low","close","volume"])
    df["datetime"] = pd.to_datetime(df["datetime"])
    df.set_index("datetime", inplace=True)
    return df

# Main execution
if __name__ == "__main__":
    # Fetch data (example for SBIN - token 3045)
    end_date = datetime.datetime.now()
    start_date = end_date - datetime.timedelta(days=90)  # More data for training
    
    try:
        df = fetch_intraday_data("3045", start_date, end_date, "FIVE_MINUTE")
        
        # Initialize Backtrader
        cerebro = bt.Cerebro()
        
        # Add data feed
        data_feed = bt.feeds.PandasData(dataname=df)
        cerebro.adddata(data_feed)
        
        # Add strategy
        cerebro.addstrategy(EnsembleStrategy)
        
        # Set initial capital and commission
        cerebro.broker.setcash(20000)  # ₹20,000 capital
        cerebro.broker.setcommission(commission=0.0)  # 0% commission as specified
        
        # Add analyzers
        cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name='sharpe')
        cerebro.addanalyzer(bt.analyzers.DrawDown, _name='drawdown')
        cerebro.addanalyzer(bt.analyzers.Returns, _name='returns')
        cerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name='trades')
        
        print(f"Starting Portfolio Value: ₹{cerebro.broker.getvalue():.2f}")
        
        # Run backtest
        results = cerebro.run()
        
        # Print results
        final_value = cerebro.broker.getvalue()
        print(f"Final Portfolio Value: ₹{final_value:.2f}")
        print(f"Total Return: ₹{final_value - 20000:.2f}")
        print(f"ROI: {((final_value - 20000) / 20000) * 100:.2f}%")
        
        # Get analyzer results
        strat = results[0]
        sharpe = strat.analyzers.sharpe.get_analysis()
        drawdown = strat.analyzers.drawdown.get_analysis()
        returns = strat.analyzers.returns.get_analysis()
        trades = strat.analyzers.trades.get_analysis()
        
        print(f"\nPerformance Metrics:")
        print(f"Sharpe Ratio: {sharpe.get('sharperatio', 0):.3f}")
        print(f"Max Drawdown: {drawdown.get('max', {}).get('drawdown', 0):.2f}%")
        print(f"Total Trades: {trades.get('total', {}).get('total', 0)}")
        print(f"Win Rate: {(trades.get('won', {}).get('total', 0) / max(trades.get('total', {}).get('total', 1), 1)) * 100:.2f}%")
        
    except Exception as e:
        print(f"Error occurred: {e}")
        print("Please ensure your Angel One API credentials are correct and you have access to historical data.")

# Alternative simple ensemble approach for immediate use
class SimpleEnsembleStrategy(bt.Strategy):
    """Simplified version of ensemble strategy for immediate deployment"""
    
    def __init__(self):
        # Multiple timeframe EMAs
        self.ema_fast = bt.indicators.EMA(self.data.close, period=8)
        self.ema_medium = bt.indicators.EMA(self.data.close, period=21)
        self.ema_slow = bt.indicators.EMA(self.data.close, period=55)
        
        # Technical indicators
        self.rsi = bt.indicators.RSI(self.data.close, period=14)
        self.macd = bt.indicators.MACD(self.data.close)
        self.bb = bt.indicators.BollingerBands(self.data.close)
        self.atr = bt.indicators.ATR(self.data)
        
        # Volume indicators
        self.volume_sma = bt.indicators.SMA(self.data.volume, period=20)
        
    def next(self):
        # Multi-signal approach
        signals = []
        
        # EMA signals
        if self.ema_fast > self.ema_medium > self.ema_slow:
            signals.append(1)  # Bullish
        elif self.ema_fast < self.ema_medium < self.ema_slow:
            signals.append(-1)  # Bearish
        else:
            signals.append(0)  # Neutral
        
        # RSI signal
        if self.rsi < 35:
            signals.append(1)  # Oversold
        elif self.rsi > 65:
            signals.append(-1)  # Overbought
        else:
            signals.append(0)
        
        # MACD signal
        if self.macd.macd > self.macd.signal:
            signals.append(1)
        else:
            signals.append(-1)
        
        # Bollinger Band signal
        if self.data.close < self.bb.bot:
            signals.append(1)  # Oversold
        elif self.data.close > self.bb.top:
            signals.append(-1)  # Overbought
        else:
            signals.append(0)
        
        # Volume confirmation
        volume_signal = 1 if self.data.volume > self.volume_sma else 0
        
        # Aggregate signals
        total_signal = sum(signals)
        
        # Position management
        if not self.position:
            if total_signal >= 2 and volume_signal:  # Strong buy
                size = int(self.broker.cash * 0.95 / self.data.close)
                self.buy(size=size)
            elif total_signal <= -2 and volume_signal:  # Strong sell
                size = int(self.broker.cash * 0.95 / self.data.close)
                self.sell(size=size)
        else:
            # Exit conditions
            if self.position.size > 0 and total_signal <= -1:
                self.close()
            elif self.position.size < 0 and total_signal >= 1:
                self.close()

print("\n" + "="*60)
print("ADVANCED ENSEMBLE TRADING STRATEGY DEPLOYED")
print("="*60)
print("Key Features:")
print("• Multi-agent reinforcement learning ensemble")
print("• LSTM with attention mechanism")
print("• CNN feature extraction")
print("• Sentiment analysis integration")
print("• Dynamic risk management")
print("• Advanced technical indicators")
print("="*60)
